<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PDF Book Core Example</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <div class="container">
    <div class="controls">
      <button id="prevBtn">Previous Page</button>
      <span id="pageInfo">Page 1 of 1</span>
      <button id="nextBtn">Next Page</button>
      <label for="fileInput">Select PDF file:
        <input type="file" id="fileInput" accept=".pdf" title="Choose a PDF file" placeholder="Choose a PDF file">
      </label>
    </div>
    <canvas id="pdfCanvas" class="pdf-canvas"></canvas>
  </div>

  <script type="module">
    import { PustakaCore } from '../dist/pustaka.esm.js';

    // Set PDF.js worker
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    const canvas = document.getElementById('pdfCanvas');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const pageInfo = document.getElementById('pageInfo');
    const fileInput = document.getElementById('fileInput');

    let Pustaka = null;

    // Custom file fetcher for demonstration
    const fileFetcher = async (url) => {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      return await response.arrayBuffer();
    };

    // Initialize PDF Book Core
    const initializePustaka = (pdfSource) => {
      if (Pustaka) {
        Pustaka.dispose();
      }

      Pustaka = new PustakaCore({
        canvas: canvas,
        pdfSource: pdfSource,
        fileFetcher: fileFetcher
      });

      // Event listeners
      Pustaka.on('ready', ({ totalPages }) => {
        console.log(`PDF loaded with ${totalPages} pages`);
        updatePageInfo();
        updateButtons();
      });

      Pustaka.on('error', ({ message, error }) => {
        console.error('PDF Book Error:', message, error);
        alert(`Error: ${message}`);
      });

      Pustaka.on('pageChanged', ({ currentPage }) => {
        updatePageInfo();
        updateButtons();
      });

      Pustaka.on('pageLoaded', ({ pageNumber, page }) => {
        console.log(`Page ${pageNumber} loaded`);
      });

      Pustaka.on('renderComplete', ({ frameTime }) => {
        // Optional: Monitor performance
        if (frameTime > 16) { // More than 16ms (60fps threshold)
          console.warn(`Slow frame: ${frameTime}ms`);
        }
      });
    };

    const updatePageInfo = () => {
      if (Pustaka && Pustaka.isReady()) {
        pageInfo.textContent = `Page ${Pustaka.getCurrentPage()} of ${Pustaka.getTotalPages()}`;
      }
    };

    const updateButtons = () => {
      if (Pustaka && Pustaka.isReady()) {
        prevBtn.disabled = Pustaka.getCurrentPage() <= 1;
        nextBtn.disabled = Pustaka.getCurrentPage() >= Pustaka.getTotalPages();
      }
    };

    // Event listeners
    prevBtn.addEventListener('click', async () => {
      if (Pustaka) {
        try {
          await Pustaka.previousPage();
        } catch (error) {
          console.error('Error going to previous page:', error);
        }
      }
    });

    nextBtn.addEventListener('click', async () => {
      if (Pustaka) {
        try {
          await Pustaka.nextPage();
        } catch (error) {
          console.error('Error going to next page:', error);
        }
      }
    });

    fileInput.addEventListener('change', async (event) => {
      const file = event.target.files[0];
      if (file && file.type === 'application/pdf') {
        try {
          const arrayBuffer = await file.arrayBuffer();
          initializePustaka(arrayBuffer);
        } catch (error) {
          console.error('Error loading file:', error);
          alert('Error loading PDF file');
        }
      }
    });

    // Handle canvas resize
    const resizeCanvas = () => {
      const container = canvas.parentElement;
      const containerRect = container.getBoundingClientRect();

      // A4 aspect ratio (210mm x 297mm ≈ 1:√2)
      const A4_ASPECT_RATIO = 210 / 297; // ≈ 0.707

      // Get maximum available space with some padding
      const maxWidth = Math.min(750, containerRect.width - 40);
      const maxHeight = Math.min(820, window.innerHeight - 200);

      // Calculate dimensions that maintain A4 aspect ratio
      let width, height;

      // Check if container is wider than A4 aspect ratio
      if (maxWidth / maxHeight > A4_ASPECT_RATIO) {
        // Container is wider than A4 - constrain by height
        height = maxHeight;
        width = height * A4_ASPECT_RATIO;
      } else {
        // Container is taller than A4 - constrain by width
        width = maxWidth;
        height = width / A4_ASPECT_RATIO;
      }

      // Ensure we don't exceed maximum dimensions
      width = Math.min(width, maxWidth);
      height = Math.min(height, maxHeight);

      // Apply the calculated dimensions
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';

      // Set the actual canvas size (accounting for device pixel ratio)
      const dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;

      // Notify the PDF book of the resize
      if (Pustaka) {
        Pustaka.resize(width * dpr, height * dpr);
      }

      console.log(`Resized canvas to ${width}x${height} (${width * dpr}x${height * dpr} @ ${dpr}x)`);
    };

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Load a sample PDF (replace with your own URL)
    initializePustaka('./sample.pdf');
  </script>
</body>

</html>